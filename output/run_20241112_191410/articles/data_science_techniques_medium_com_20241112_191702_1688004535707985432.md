---
bundle: data_science_techniques
url: https://medium.com/towards-data-science/random-forest-explained-a-visual-guide-with-code-examples-9f736a6e1b3c
fetch_date: 2024-11-12T19:17:02.132949
length: 52547
category: Towards Data Science
cleaned_patterns: True
---

Title: Random Forest | Towards Data Science

URL Source: https://medium.com/towards-data-science/random-forest-explained-a-visual-guide-with-code-examples-9f736a6e1b3c

Published Time: 2024-11-07T13:02:11.895Z

Markdown Content:
ENSEMBLE LEARNING
-----------------

Random Forest, Explained: A Visual Guide with Code Examples
-----------------------------------------------------------

Making tree-mendous predictions with random trees
-------------------------------------------------

[![Image 1: Samy Baladram](https://miro.medium.com/v2/resize:fill:88:88/1*M5J7CK552m9f4z-m1F7vYg.png)](https://medium.com/@samybaladram?source=post_page---byline--9f736a6e1b3c--------------------------------)

[Decision trees](https://towardsdatascience.com/decision-tree-classifier-explained-a-visual-guide-with-code-examples-for-beginners-7c863f06a71e) are a great starting point in machine learning — they’re clear and make sense. But there’s a catch: they often don’t work well when dealing with new data. The predictions can be inconsistent and unreliable, which is a real problem when you’re trying to build something useful.

This is where Random Forest comes in. It takes what’s good about decision trees and makes them work better by combining multiple trees together. It’s become a favorite tool for many data scientists because it’s both effective and practical.

Let’s see how Random Forest works and why it might be exactly what you need for your next project. It’s time to stop getting lost in the trees and see the forest for what it really is — your next reliable tool in machine learning.

![Image 3: a cartoon character is standing in front of a bunch of trees](https://miro.medium.com/v2/resize:fit:700/1*FBhxEgEzbfYWiSK0LYOv6g.gif)

All visuals: Author-created using Canva Pro. Optimized for mobile; may appear oversized on desktop.

Definition
----------

A Random Forest is an ensemble machine learning model that combines multiple decision trees. Each tree in the forest is trained on a random sample of the data (bootstrap sampling) and considers only a random subset of features when making splits (feature randomization).

For classification tasks, the forest predicts by majority voting among trees, while for regression tasks, it averages the predictions. The model’s strength comes from its “wisdom of crowds” approach — while individual trees might make errors, the collective decision-making process **tends to average out these mistakes** and arrive at more reliable predictions.

Random Forest is a part of bagging (bootstrap aggregating) algorithm because it builds each tree using different random part of data and combines their answers together.

Dataset Used
------------

Throughout this article, we’ll focus on the classic golf dataset as an example for classification. While Random Forests can handle both classification and regression tasks equally well, we’ll concentrate on the classification part — predicting whether someone will play golf based on weather conditions. The concepts we’ll explore can be easily adapted to regression problems (like predicting number of player) using the same principles.

![Image 5: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*O0_DqZWXc5OM--Zxp3_uuw.png)

Columns: ‘Overcast (one-hot-encoded into 3 columns)’, ’Temperature’ (in Fahrenheit), ‘Humidity’ (in %), ‘Windy’ (Yes/No) and ‘Play’ (Yes/No, target feature)

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_splitdataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rainy', 'rainy', 'rainy', 'overcast',   
                'sunny', 'sunny', 'rainy', 'sunny', 'overcast', 'overcast', 'rainy',  
                'sunny', 'overcast', 'rainy', 'sunny', 'sunny', 'rainy', 'overcast',  
                'rainy', 'sunny', 'overcast', 'sunny', 'overcast', 'rainy', 'overcast'\],  
    'Temperature': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
                   72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
                   88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humidity': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
                 90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
                 65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Play': \['No', 'No', 'Yes', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes',  
             'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'Yes', 'Yes',  
             'Yes', 'Yes', 'Yes', 'Yes', 'No', 'Yes'\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='', dtype=int)  
df\['Wind'\] = df\['Wind'\].astype(int)  
df\['Play'\] = (df\['Play'\] == 'Yes').astype(int)

column\_order = \['sunny', 'overcast', 'rainy', 'Temperature', 'Humidity', 'Wind', 'Play'\]  
df = df\[column\_order\]

X,y = df.drop('Play', axis=1), df\['Play'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

Main Mechanism
--------------

Here’s how Random Forest works:

1.  **Bootstrap Sampling:** Each tree gets its own unique training set, created by randomly sampling from the original data with replacement. This means some data points may appear multiple times while others aren’t used.
2.  **Random Feature Selection:** When making a split, each tree only considers a random subset of features (typically square root of total features).
3.  **Growing Trees:** Each tree grows using only its bootstrap sample and selected features, making splits until it reaches a stopping point (like pure groups or minimum sample size).
4.  **Final Prediction:** All trees vote together for the final prediction. For classification, take the majority vote of class predictions; for regression, average the predicted values from all trees.

![Image 6: a diagram showing the process of a data model](https://miro.medium.com/v2/resize:fit:700/1*FisK9hkTkWP2D92ANxAp9w.png)

A Random Forest Classifier makes predictions by combining results from 100 different decision trees, each analyzing features like temperature and outlook conditions. The final prediction comes from the most common answer among all trees.

Training Steps
--------------

The Random Forest algorithm constructs multiple decision trees and combines them. Here’s how it works:

**Step 1: Bootstrap Sample Creation**  
1.0. Set the number of trees (default = 100)  
1.1. For each tree in the forest:  
a. Create new training set by random sampling original data with replacement until reaching original dataset size. This is called **bootstrap sampling**.  
b. Mark and set aside non-selected samples as out-of-bag (OOB) samples for later error estimation

Random Forest creates different training sets for each tree by randomly picking data points from the original training set, with some numbers appearing multiple times. The unused data points become test sets for checking each tree’s performance.

  
n\_samples = len(X\_train)  
n\_bootstraps = 100  
all\_bootstrap\_indices = \[\]  
all\_oob\_indices = \[\]np.random.seed(42)    
for i in range(n\_bootstraps):  
      
    bootstrap\_indices = np.random.choice(n\_samples, size=n\_samples, replace=True)

oob\_indices = list(set(range(n\_samples)) - set(bootstrap\_indices))

all\_bootstrap\_indices.append(bootstrap\_indices)  
    all\_oob\_indices.append(oob\_indices)

samples\_to\_show = \[0, 1, 99\]

for i in samples\_to\_show:  
    print(f"\\nBootstrap Sample {i+1}:")  
    print(f"Chosen indices: {sorted(all\_bootstrap\_indices\[i\])}")  
    print(f"Number of unique chosen indices: {len(set(all\_bootstrap\_indices\[i\]))}")  
    print(f"OOB indices: {sorted(all\_oob\_indices\[i\])}")  
    print(f"Number of OOB samples: {len(all\_oob\_indices\[i\])}")  
    print(f"Percentage of OOB: {len(all\_oob\_indices\[i\])/n\_samples\*100:.1f}%")

![Image 8: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*_smMUwVcgHdpla5vGIDVrw.png)

Notice how similar the percentages of OOB above? When doing bootstrap sampling of _n_ samples, each individual sample has about a 37% chance of never being picked. This comes from the probability calculation (1–1/_n_)_ⁿ_, which approaches 1/e ≈ 0.368 as _n_ gets larger. That’s why each tree ends up using roughly 63% of the data for training, with the remaining 37% becoming OOB samples.

**Step 2: Tree Construction**  
2.1. Start at root node with complete bootstrap sample

![Image 9: a table with a number of numbers and a number of numbers](https://miro.medium.com/v2/resize:fit:700/1*v4X7vEWV5j1oOfEX4R5lRw.png)

When building each decision tree, Random Forest considers a subset of data points and creates splits based on questions about their values — sending smaller values to the left and larger values to the right to make predictions.

a. Calculate initial node impurity using all samples in node  
· Classification: Gini or entropy  
· Regression: MSE

![Image 10: a screen showing the number of a number and the number of a number](https://miro.medium.com/v2/resize:fit:700/1*zNarI6dKgX4FiJjFyD3n2Q.png)

Random Forest starts by calculating the Gini Impurity of the entire dataset (before any splits) using the ratio of YES and NO labels — a measure of how mixed the labels are in the current data.

b. Select random subset of features from total available features:  
· Classification: √n\_features  
· Regression: n\_features/3

For each split in a tree, Random Forest randomly picks a subset of weather features (here 2 out of 6) to consider, making each tree focus on different aspects of the data.

c. For each selected feature:  
· Sort data points by feature values  
· Identify potential split points (midpoints between consecutive unique feature values)

![Image 12: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*2e-uAc0hSvvdidQkFAZFmQ.png)

For each chosen feature, Random Forest looks at all possible split points in the sorted data (like temperature values 66.0, 69.0, 71.0, etc.) to find the best way to separate the data into two groups.

d. For each potential split point:  
· Divide samples into left and right groups  
· Calculate left child impurity using its samples  
· Calculate right child impurity using its samples  
· Calculate impurity reduction:  
parent\_impurity — (left\_weight × left\_impurity + right\_weight × right\_impurity)

![Image 13: a diagram showing the process of a number of numbers](https://miro.medium.com/v2/resize:fit:700/1*mhNv0BglEfXOxkyBJ6c2bg.png)

To find the best split point, Random Forest calculates Gini Impurity for each possible split, takes a weighted average based on group sizes, and picks the split that gives the biggest reduction in impurity from the parent node.

e. Split the current node data using the feature and split point that gives the highest impurity reduction. Then pass data points to the respective child nodes.

After comparing all possible splits, Random Forest picks the temperature threshold of 73.5°F as it gives the largest impurity reduction (0.041), creating two groups: one mixed group with temperatures below 73.5°F and one pure group.

f. For each child node, repeat the process (step b-e) until:  
\- Pure node or minimum impurity decrease  
\- Minimum samples threshold  
\- Maximum depth  
\- Maximum leaf nodes

![Image 15: a diagram showing the process of a cloud service](https://miro.medium.com/v2/resize:fit:700/1*QPkjzqkKWFGdwFI3VVZzGw.png)

This process continues for each new group (node): randomly select features, find the best split point, and divide the data further until each group is pure (all YES or all NO) or can’t be split anymore.

**Step 3: Tree Construction  
**Repeat the whole Step 2 for other bootstrap samples.

![Image 16: a tree diagram showing different types of water](https://miro.medium.com/v2/resize:fit:700/1*u9omyxuFVrVnM8HbmTCt3A.png)

Each decision tree in the Random Forest splits data in different ways using different features and thresholds. This variety helps the forest make better predictions than any single tree.

from sklearn.tree import plot\_tree  
from sklearn.ensemble import RandomForestClassifiernp.random.seed(42)    
rf = RandomForestClassifier(n\_estimators=100, random\_state=42)  
rf.fit(X\_train, y\_train)

trees\_to\_show = \[0, 1, 99\]    
feature\_names = X\_train.columns.tolist()  
class\_names = \['No', 'Yes'\]

fig, axes = plt.subplots(1, 3, figsize=(20, 6), dpi=300)    
fig.suptitle('Decision Trees from Random Forest', fontsize=16)

for idx, tree\_idx in enumerate(trees\_to\_show):  
    plot\_tree(rf.estimators\_\[tree\_idx\],   
              feature\_names=feature\_names,  
              class\_names=class\_names,  
              filled=True,  
              rounded=True,  
              ax=axes\[idx\],  
              fontsize=10)    
    axes\[idx\].set\_title(f'Tree {tree\_idx + 1}', fontsize=12)

plt.tight\_layout(rect=\[0, 0.03, 1, 0.95\])

![Image 17: a tree diagram showing different types of trees](https://miro.medium.com/v2/resize:fit:700/1*boY9Qp94g4ISXJig9TjWEQ.png)

Accessing the internal bootstrap indices directly isn’t possible in the current scikit-learn implementation so this gives different trees than the one calculated in our previous example.

Testing Step
------------

For prediction, route new samples through all trees and aggregate:  
\- Classification: majority vote  
\- Regression: mean prediction

When new data comes in, each tree in the Random Forest uses its own decision path to make a prediction. The forest combines all these predictions (74 YES vs 26 NO) and the majority vote becomes the final answer (YES in this case).

Out-of-Bag (OOB) Evaluation
---------------------------

Remember those samples that didn’t get used for training each tree — that leftover 1/3? Those are your OOB samples. Instead of just ignoring them, Random Forest uses them as a convenient validation set for each tree.

![Image 19: a diagram showing the process of a business](https://miro.medium.com/v2/resize:fit:700/1*iX_BcJIgo4xt7_pwhOp2uA.png)

Each tree gets tested on its own out-of-bag samples (data not used in its training). By averaging these individual OOB accuracy scores (50%, 66.6%, 60%), Random Forest provides a built-in way to measure performance without needing a separate test set.

Evaluation Step
---------------

After building all the trees, we can evaluate the test set.

![Image 20: a bar chart showing the percentage of the number of people who are using the app](https://miro.medium.com/v2/resize:fit:700/1*i9HhZ7Qb-PNAj8Dz1BS__g.png)

By combining multiple diverse decision trees and using majority voting, Random Forest achieves a high accuracy of 85.7% — typically better than single decision trees or simpler models!

Key Parameters
--------------

The key Random Forest parameters (especially in `scikit-learn`) include all Decision Tree parameters, plus some unique ones.

Random Forest-specific parameters
---------------------------------

*   ```
    oob_score  
    ```This uses leftover data (out-of-bag samples) to check how well the model works. This gives you a way to test your model without setting aside separate test data. It’s especially helpful with small datasets.
*   ```
    n_estimators  
    ```This parameter controls how many trees to build (default is 100).To find the optimal number of trees, **track the OOB error rate** as you add more trees to the forest. The error typically drops quickly at first, then levels off. **The point where it stabilizes suggests the optimal number** — adding more trees after this gives minimal improvement while increasing computation time.

  
n\_trees\_range = range(10, 201)  
oob\_errors = \[  
    1 - RandomForestClassifier(n\_estimators=n, oob\_score=True, random\_state=42).fit(X\_train, y\_train).oob\_score\_  
    for n in n\_trees\_range  
\]plt.figure(figsize=(7, 5), dpi=300)  
plt.plot(n\_trees\_range, oob\_errors, 'b-', linewidth=2)  
plt.xlabel('Number of Trees')  
plt.ylabel('Out-of-Bag Error Rate')  
plt.title('Random Forest OOB Error vs Number of Trees')  
plt.grid(True, alpha=0.2)  
plt.tight\_layout()

print("OOB Error by Number of Trees:")  
for i, error in enumerate(oob\_errors, 1):  
    if i % 10 == 0:  
        print(f"Trees: {i:3d}, OOB Error: {error:.4f}")

![Image 21: a table showing the number of trees in a tree](https://miro.medium.com/v2/resize:fit:700/1*QZGLjKBkq2Sv4GcJKALRgA.png)

![Image 22: random forest cdo error number of trees](https://miro.medium.com/v2/resize:fit:700/1*L2s739Wdeb89lNjtMLKznQ.png)

In our results, while around 27 trees showed the best score (0.2857), this early performance can be unreliable. Between 40–100 trees, the error rates settle around 0.5000, showing more consistent results. Using more than 100 trees doesn’t help and sometimes makes things worse. This suggests that using about 50–60 trees is a good choice — it’s stable, efficient, and reliable.

*   ```
    bootstrap  
    ```This decides whether each tree learns from a random sample of data (`True`) or uses all data ( `False`). The default (`True`) helps create different kinds of trees, which is key to how Random Forests work. Only consider **setting it to** `**False**` **when you have very little data** and can’t afford to skip any samples.
*   ```
    n_jobs  
    ```This controls how many processor cores to use during training. Setting it to `-1` uses all available cores, making training faster but using more memory. With big datasets, you might need to use fewer cores to avoid running out of memory.

Shared parameters with Decision Trees
-------------------------------------

The following parameters works the [same way as in Decision Tree](https://towardsdatascience.com/decision-tree-classifier-explained-a-visual-guide-with-code-examples-for-beginners-7c863f06a71e).

*   `max_depth`: Maximum tree depth
*   `min_samples_split`: Minimum samples needed to split a node
*   `min_samples_leaf`: Minimum samples required at leaf node

Compared to Decision Tree, here are key differences in parameter importance:

1.  ```
    max_depth  
    ```This matters less in Random Forests because combining many trees helps prevent overfitting, even with deeper trees. You can usually let trees grow deeper to catch complex patterns in your data.
2.  `min_samples_split` and ```
    min_samples_leaf  
    ```These are less important in Random Forests because using many trees naturally helps avoid overfitting. You can usually set these to smaller numbers than you would with a single decision tree.

Pros & Cons
-----------

Pros:
-----

1.  **Strong and Reliable:** Random Forests give accurate results and are less likely to overfit than single decision trees. By using random sampling and mixing up which features each tree considers at each node, they work well across many problems without needing much adjustment.
2.  **Feature Importance:** The model can tell you which features matter most in making predictions by measuring how much each feature helps across all trees. This helps you understand what drives your predictions.
3.  **Minimal Preprocessing:** Random Forests handle both numerical and categorical variables well without much preparation. They work well with missing values and outliers, and can find complex relationships in your data automatically.

Cons:
-----

1.  **Computational Cost:** Training and using the model takes more time as you add more trees or make them deeper. While you can speed up training by using multiple processors, it still needs substantial computing power for big datasets.
2.  **Limited Interpretability:** While you can see which features are important overall, it’s harder to understand exactly why the model made a specific prediction, unlike with single decision trees. This can be a problem when you need to explain each decision.
3.  **Prediction Speed:** To make a prediction, data must go through all trees and then combine their answers. This makes Random Forests slower than simpler models, which might be an issue for real-time applications.

Final Remarks
-------------

I’ve grown to really like Random Forests after seeing how well they work in practice. By combining multiple trees and letting each one learn from different parts of the data, they consistently make better predictions — of course, more than using just one tree alone.

While you do need to adjust some settings like the number of trees, they usually perform well even without much fine-tuning. They do need more computing power (and sometimes struggle with rare cases in the data) but their reliable performance and ease of use make them my go-to choice for many projects. It’s clear why so many data scientists feel the same way!

🌟 Random Forest Classifier Code Summarized
-------------------------------------------

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_split  
from sklearn.metrics import accuracy\_score  
from sklearn.ensemble import RandomForestClassifierdataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rainy', 'rainy', 'rainy', 'overcast',   
                'sunny', 'sunny', 'rainy', 'sunny', 'overcast', 'overcast', 'rainy',  
                'sunny', 'overcast', 'rainy', 'sunny', 'sunny', 'rainy', 'overcast',  
                'rainy', 'sunny', 'overcast', 'sunny', 'overcast', 'rainy', 'overcast'\],  
    'Temperature': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
                   72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
                   88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humidity': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
                 90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
                 65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Play': \['No', 'No', 'Yes', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes',  
             'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'Yes', 'Yes',  
             'Yes', 'Yes', 'Yes', 'Yes', 'No', 'Yes'\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='', dtype=int)  
df\['Wind'\] = df\['Wind'\].astype(int)  
df\['Play'\] = (df\['Play'\] == 'Yes').astype(int)

column\_order = \['sunny', 'overcast', 'rainy', 'Temperature', 'Humidity', 'Wind', 'Play'\]  
df = df\[column\_order\]

X, y = df.drop('Play', axis=1), df\['Play'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

rf = RandomForestClassifier(n\_estimators=100, max\_features='sqrt', random\_state=42)  
rf.fit(X\_train, y\_train)

y\_pred = rf.predict(X\_test)  
print(f"Accuracy: {accuracy\_score(y\_test, y\_pred)}")

🌟 Random Forest Regressor Code Summarized
------------------------------------------

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_split  
from sklearn.metrics import root\_mean\_squared\_error  
from sklearn.ensemble import RandomForestRegressordataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rain', 'rain', 'rain', 'overcast',   
                'sunny', 'sunny', 'rain', 'sunny', 'overcast', 'overcast', 'rain',  
                'sunny', 'overcast', 'rain', 'sunny', 'sunny', 'rain', 'overcast',  
                'rain', 'sunny', 'overcast', 'sunny', 'overcast', 'rain', 'overcast'\],  
    'Temp.': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
              72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
              88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humid.': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
               90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
               65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Num\_Players': \[52, 39, 43, 37, 28, 19, 43, 47, 56, 33, 49, 23, 42, 13, 33, 29,  
                    25, 51, 41, 14, 34, 29, 49, 36, 57, 21, 23, 41\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='')  
df\['Wind'\] = df\['Wind'\].astype(int)

X, y = df.drop('Num\_Players', axis=1), df\['Num\_Players'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

rf = RandomForestRegressor(n\_estimators=100, max\_features='sqrt', random\_state=42)  
rf.fit(X\_train, y\_train)

y\_pred = rf.predict(X\_test)  
rmse = root\_mean\_squared\_error(y\_test, y\_pred)

print(f"Root Mean Squared Error: {rmse:.2f}")

Further Reading
---------------

For a detailed explanation of the [RandomForestClassifier](https://scikit-learn.org/1.5/modules/generated/sklearn.ensemble.RandomForestClassifier.html) and [RandomForestRegressor](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html) and its implementation in scikit-learn, readers can refer to the official documentation, which provides comprehensive information on its usage and parameters.

Technical Environment
---------------------

This article uses Python 3.7 and scikit-learn 1.5. While the concepts discussed are generally applicable, specific code implementations may vary slightly with different versions.

About the Illustrations
-----------------------

Unless otherwise noted, all images are created by the author, incorporating licensed design elements from Canva Pro.


## Visual Content Analysis

### Image Analysis
Title: Random Forest | Towards Data Science

URL Source: https://medium.com/towards-data-science/random-forest-explained-a-visual-guide-with-code-examples-9f736a6e1b3c

Published Time: 2024-11-07T13:02:11.895Z

Markdown Content:
ENSEMBLE LEARNING
-----------------

Random Forest, Explained: A Visual Guide with Code Examples
-----------------------------------------------------------

Making tree-mendous predictions with random trees
-------------------------------------------------

[![Image 1: Samy Baladram](https://miro.medium.com/v2/resize:fill:88:88/1*M5J7CK552m9f4z-m1F7vYg.png)](https://medium.com/@samybaladram?source=post_page---byline--9f736a6e1b3c--------------------------------)

[Decision trees](https://towardsdatascience.com/decision-tree-classifier-explained-a-visual-guide-with-code-examples-for-beginners-7c863f06a71e) are a great starting point in machine learning — they’re clear and make sense. But there’s a catch: they often don’t work well when dealing with new data. The predictions can be inconsistent and unreliable, which is a real problem when you’re trying to build something useful.

This is where Random Forest comes in. It takes what’s good about decision trees and makes them work better by combining multiple trees together. It’s become a favorite tool for many data scientists because it’s both effective and practical.

Let’s see how Random Forest works and why it might be exactly what you need for your next project. It’s time to stop getting lost in the trees and see the forest for what it really is — your next reliable tool in machine learning.

![Image 3: a cartoon character is standing in front of a bunch of trees](https://miro.medium.com/v2/resize:fit:700/1*FBhxEgEzbfYWiSK0LYOv6g.gif)

All visuals: Author-created using Canva Pro. Optimized for mobile; may appear oversized on desktop.

Definition
----------

A Random Forest is an ensemble machine learning model that combines multiple decision trees. Each tree in the forest is trained on a random sample of the data (bootstrap sampling) and considers only a random subset of features when making splits (feature randomization).

For classification tasks, the forest predicts by majority voting among trees, while for regression tasks, it averages the predictions. The model’s strength comes from its “wisdom of crowds” approach — while individual trees might make errors, the collective decision-making process **tends to average out these mistakes** and arrive at more reliable predictions.

Random Forest is a part of bagging (bootstrap aggregating) algorithm because it builds each tree using different random part of data and combines their answers together.

Dataset Used
------------

Throughout this article, we’ll focus on the classic golf dataset as an example for classification. While Random Forests can handle both classification and regression tasks equally well, we’ll concentrate on the classification part — predicting whether someone will play golf based on weather conditions. The concepts we’ll explore can be easily adapted to regression problems (like predicting number of player) using the same principles.

![Image 5: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*O0_DqZWXc5OM--Zxp3_uuw.png)

Columns: ‘Overcast (one-hot-encoded into 3 columns)’, ’Temperature’ (in Fahrenheit), ‘Humidity’ (in %), ‘Windy’ (Yes/No) and ‘Play’ (Yes/No, target feature)

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_splitdataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rainy', 'rainy', 'rainy', 'overcast',   
                'sunny', 'sunny', 'rainy', 'sunny', 'overcast', 'overcast', 'rainy',  
                'sunny', 'overcast', 'rainy', 'sunny', 'sunny', 'rainy', 'overcast',  
                'rainy', 'sunny', 'overcast', 'sunny', 'overcast', 'rainy', 'overcast'\],  
    'Temperature': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
                   72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
                   88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humidity': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
                 90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
                 65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Play': \['No', 'No', 'Yes', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes',  
             'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'Yes', 'Yes',  
             'Yes', 'Yes', 'Yes', 'Yes', 'No', 'Yes'\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='', dtype=int)  
df\['Wind'\] = df\['Wind'\].astype(int)  
df\['Play'\] = (df\['Play'\] == 'Yes').astype(int)

column\_order = \['sunny', 'overcast', 'rainy', 'Temperature', 'Humidity', 'Wind', 'Play'\]  
df = df\[column\_order\]

X,y = df.drop('Play', axis=1), df\['Play'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

Main Mechanism
--------------

Here’s how Random Forest works:

1.  **Bootstrap Sampling:** Each tree gets its own unique training set, created by randomly sampling from the original data with replacement. This means some data points may appear multiple times while others aren’t used.
2.  **Random Feature Selection:** When making a split, each tree only considers a random subset of features (typically square root of total features).
3.  **Growing Trees:** Each tree grows using only its bootstrap sample and selected features, making splits until it reaches a stopping point (like pure groups or minimum sample size).
4.  **Final Prediction:** All trees vote together for the final prediction. For classification, take the majority vote of class predictions; for regression, average the predicted values from all trees.

![Image 6: a diagram showing the process of a data model](https://miro.medium.com/v2/resize:fit:700/1*FisK9hkTkWP2D92ANxAp9w.png)

A Random Forest Classifier makes predictions by combining results from 100 different decision trees, each analyzing features like temperature and outlook conditions. The final prediction comes from the most common answer among all trees.

Training Steps
--------------

The Random Forest algorithm constructs multiple decision trees and combines them. Here’s how it works:

**Step 1: Bootstrap Sample Creation**  
1.0. Set the number of trees (default = 100)  
1.1. For each tree in the forest:  
a. Create new training set by random sampling original data with replacement until reaching original dataset size. This is called **bootstrap sampling**.  
b. Mark and set aside non-selected samples as out-of-bag (OOB) samples for later error estimation

Random Forest creates different training sets for each tree by randomly picking data points from the original training set, with some numbers appearing multiple times. The unused data points become test sets for checking each tree’s performance.

  
n\_samples = len(X\_train)  
n\_bootstraps = 100  
all\_bootstrap\_indices = \[\]  
all\_oob\_indices = \[\]np.random.seed(42)    
for i in range(n\_bootstraps):  
      
    bootstrap\_indices = np.random.choice(n\_samples, size=n\_samples, replace=True)

oob\_indices = list(set(range(n\_samples)) - set(bootstrap\_indices))

all\_bootstrap\_indices.append(bootstrap\_indices)  
    all\_oob\_indices.append(oob\_indices)

samples\_to\_show = \[0, 1, 99\]

for i in samples\_to\_show:  
    print(f"\\nBootstrap Sample {i+1}:")  
    print(f"Chosen indices: {sorted(all\_bootstrap\_indices\[i\])}")  
    print(f"Number of unique chosen indices: {len(set(all\_bootstrap\_indices\[i\]))}")  
    print(f"OOB indices: {sorted(all\_oob\_indices\[i\])}")  
    print(f"Number of OOB samples: {len(all\_oob\_indices\[i\])}")  
    print(f"Percentage of OOB: {len(all\_oob\_indices\[i\])/n\_samples\*100:.1f}%")

![Image 8: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*_smMUwVcgHdpla5vGIDVrw.png)

Notice how similar the percentages of OOB above? When doing bootstrap sampling of _n_ samples, each individual sample has about a 37% chance of never being picked. This comes from the probability calculation (1–1/_n_)_ⁿ_, which approaches 1/e ≈ 0.368 as _n_ gets larger. That’s why each tree ends up using roughly 63% of the data for training, with the remaining 37% becoming OOB samples.

**Step 2: Tree Construction**  
2.1. Start at root node with complete bootstrap sample

![Image 9: a table with a number of numbers and a number of numbers](https://miro.medium.com/v2/resize:fit:700/1*v4X7vEWV5j1oOfEX4R5lRw.png)

When building each decision tree, Random Forest considers a subset of data points and creates splits based on questions about their values — sending smaller values to the left and larger values to the right to make predictions.

a. Calculate initial node impurity using all samples in node  
· Classification: Gini or entropy  
· Regression: MSE

![Image 10: a screen showing the number of a number and the number of a number](https://miro.medium.com/v2/resize:fit:700/1*zNarI6dKgX4FiJjFyD3n2Q.png)

Random Forest starts by calculating the Gini Impurity of the entire dataset (before any splits) using the ratio of YES and NO labels — a measure of how mixed the labels are in the current data.

b. Select random subset of features from total available features:  
· Classification: √n\_features  
· Regression: n\_features/3

For each split in a tree, Random Forest randomly picks a subset of weather features (here 2 out of 6) to consider, making each tree focus on different aspects of the data.

c. For each selected feature:  
· Sort data points by feature values  
· Identify potential split points (midpoints between consecutive unique feature values)

![Image 12: a table with different numbers and numbers](https://miro.medium.com/v2/resize:fit:700/1*2e-uAc0hSvvdidQkFAZFmQ.png)

For each chosen feature, Random Forest looks at all possible split points in the sorted data (like temperature values 66.0, 69.0, 71.0, etc.) to find the best way to separate the data into two groups.

d. For each potential split point:  
· Divide samples into left and right groups  
· Calculate left child impurity using its samples  
· Calculate right child impurity using its samples  
· Calculate impurity reduction:  
parent\_impurity — (left\_weight × left\_impurity + right\_weight × right\_impurity)

![Image 13: a diagram showing the process of a number of numbers](https://miro.medium.com/v2/resize:fit:700/1*mhNv0BglEfXOxkyBJ6c2bg.png)

To find the best split point, Random Forest calculates Gini Impurity for each possible split, takes a weighted average based on group sizes, and picks the split that gives the biggest reduction in impurity from the parent node.

e. Split the current node data using the feature and split point that gives the highest impurity reduction. Then pass data points to the respective child nodes.

After comparing all possible splits, Random Forest picks the temperature threshold of 73.5°F as it gives the largest impurity reduction (0.041), creating two groups: one mixed group with temperatures below 73.5°F and one pure group.

f. For each child node, repeat the process (step b-e) until:  
\- Pure node or minimum impurity decrease  
\- Minimum samples threshold  
\- Maximum depth  
\- Maximum leaf nodes

![Image 15: a diagram showing the process of a cloud service](https://miro.medium.com/v2/resize:fit:700/1*QPkjzqkKWFGdwFI3VVZzGw.png)

This process continues for each new group (node): randomly select features, find the best split point, and divide the data further until each group is pure (all YES or all NO) or can’t be split anymore.

**Step 3: Tree Construction  
**Repeat the whole Step 2 for other bootstrap samples.

![Image 16: a tree diagram showing different types of water](https://miro.medium.com/v2/resize:fit:700/1*u9omyxuFVrVnM8HbmTCt3A.png)

Each decision tree in the Random Forest splits data in different ways using different features and thresholds. This variety helps the forest make better predictions than any single tree.

from sklearn.tree import plot\_tree  
from sklearn.ensemble import RandomForestClassifiernp.random.seed(42)    
rf = RandomForestClassifier(n\_estimators=100, random\_state=42)  
rf.fit(X\_train, y\_train)

trees\_to\_show = \[0, 1, 99\]    
feature\_names = X\_train.columns.tolist()  
class\_names = \['No', 'Yes'\]

fig, axes = plt.subplots(1, 3, figsize=(20, 6), dpi=300)    
fig.suptitle('Decision Trees from Random Forest', fontsize=16)

for idx, tree\_idx in enumerate(trees\_to\_show):  
    plot\_tree(rf.estimators\_\[tree\_idx\],   
              feature\_names=feature\_names,  
              class\_names=class\_names,  
              filled=True,  
              rounded=True,  
              ax=axes\[idx\],  
              fontsize=10)    
    axes\[idx\].set\_title(f'Tree {tree\_idx + 1}', fontsize=12)

plt.tight\_layout(rect=\[0, 0.03, 1, 0.95\])

![Image 17: a tree diagram showing different types of trees](https://miro.medium.com/v2/resize:fit:700/1*boY9Qp94g4ISXJig9TjWEQ.png)

Accessing the internal bootstrap indices directly isn’t possible in the current scikit-learn implementation so this gives different trees than the one calculated in our previous example.

Testing Step
------------

For prediction, route new samples through all trees and aggregate:  
\- Classification: majority vote  
\- Regression: mean prediction

When new data comes in, each tree in the Random Forest uses its own decision path to make a prediction. The forest combines all these predictions (74 YES vs 26 NO) and the majority vote becomes the final answer (YES in this case).

Out-of-Bag (OOB) Evaluation
---------------------------

Remember those samples that didn’t get used for training each tree — that leftover 1/3? Those are your OOB samples. Instead of just ignoring them, Random Forest uses them as a convenient validation set for each tree.

![Image 19: a diagram showing the process of a business](https://miro.medium.com/v2/resize:fit:700/1*iX_BcJIgo4xt7_pwhOp2uA.png)

Each tree gets tested on its own out-of-bag samples (data not used in its training). By averaging these individual OOB accuracy scores (50%, 66.6%, 60%), Random Forest provides a built-in way to measure performance without needing a separate test set.

Evaluation Step
---------------

After building all the trees, we can evaluate the test set.

![Image 20: a bar chart showing the percentage of the number of people who are using the app](https://miro.medium.com/v2/resize:fit:700/1*i9HhZ7Qb-PNAj8Dz1BS__g.png)

By combining multiple diverse decision trees and using majority voting, Random Forest achieves a high accuracy of 85.7% — typically better than single decision trees or simpler models!

Key Parameters
--------------

The key Random Forest parameters (especially in `scikit-learn`) include all Decision Tree parameters, plus some unique ones.

Random Forest-specific parameters
---------------------------------

*   ```
    oob_score  
    ```This uses leftover data (out-of-bag samples) to check how well the model works. This gives you a way to test your model without setting aside separate test data. It’s especially helpful with small datasets.
*   ```
    n_estimators  
    ```This parameter controls how many trees to build (default is 100).To find the optimal number of trees, **track the OOB error rate** as you add more trees to the forest. The error typically drops quickly at first, then levels off. **The point where it stabilizes suggests the optimal number** — adding more trees after this gives minimal improvement while increasing computation time.

  
n\_trees\_range = range(10, 201)  
oob\_errors = \[  
    1 - RandomForestClassifier(n\_estimators=n, oob\_score=True, random\_state=42).fit(X\_train, y\_train).oob\_score\_  
    for n in n\_trees\_range  
\]plt.figure(figsize=(7, 5), dpi=300)  
plt.plot(n\_trees\_range, oob\_errors, 'b-', linewidth=2)  
plt.xlabel('Number of Trees')  
plt.ylabel('Out-of-Bag Error Rate')  
plt.title('Random Forest OOB Error vs Number of Trees')  
plt.grid(True, alpha=0.2)  
plt.tight\_layout()

print("OOB Error by Number of Trees:")  
for i, error in enumerate(oob\_errors, 1):  
    if i % 10 == 0:  
        print(f"Trees: {i:3d}, OOB Error: {error:.4f}")

![Image 21: a table showing the number of trees in a tree](https://miro.medium.com/v2/resize:fit:700/1*QZGLjKBkq2Sv4GcJKALRgA.png)

![Image 22: random forest cdo error number of trees](https://miro.medium.com/v2/resize:fit:700/1*L2s739Wdeb89lNjtMLKznQ.png)

In our results, while around 27 trees showed the best score (0.2857), this early performance can be unreliable. Between 40–100 trees, the error rates settle around 0.5000, showing more consistent results. Using more than 100 trees doesn’t help and sometimes makes things worse. This suggests that using about 50–60 trees is a good choice — it’s stable, efficient, and reliable.

*   ```
    bootstrap  
    ```This decides whether each tree learns from a random sample of data (`True`) or uses all data ( `False`). The default (`True`) helps create different kinds of trees, which is key to how Random Forests work. Only consider **setting it to** `**False**` **when you have very little data** and can’t afford to skip any samples.
*   ```
    n_jobs  
    ```This controls how many processor cores to use during training. Setting it to `-1` uses all available cores, making training faster but using more memory. With big datasets, you might need to use fewer cores to avoid running out of memory.

Shared parameters with Decision Trees
-------------------------------------

The following parameters works the [same way as in Decision Tree](https://towardsdatascience.com/decision-tree-classifier-explained-a-visual-guide-with-code-examples-for-beginners-7c863f06a71e).

*   `max_depth`: Maximum tree depth
*   `min_samples_split`: Minimum samples needed to split a node
*   `min_samples_leaf`: Minimum samples required at leaf node

Compared to Decision Tree, here are key differences in parameter importance:

1.  ```
    max_depth  
    ```This matters less in Random Forests because combining many trees helps prevent overfitting, even with deeper trees. You can usually let trees grow deeper to catch complex patterns in your data.
2.  `min_samples_split` and ```
    min_samples_leaf  
    ```These are less important in Random Forests because using many trees naturally helps avoid overfitting. You can usually set these to smaller numbers than you would with a single decision tree.

Pros & Cons
-----------

Pros:
-----

1.  **Strong and Reliable:** Random Forests give accurate results and are less likely to overfit than single decision trees. By using random sampling and mixing up which features each tree considers at each node, they work well across many problems without needing much adjustment.
2.  **Feature Importance:** The model can tell you which features matter most in making predictions by measuring how much each feature helps across all trees. This helps you understand what drives your predictions.
3.  **Minimal Preprocessing:** Random Forests handle both numerical and categorical variables well without much preparation. They work well with missing values and outliers, and can find complex relationships in your data automatically.

Cons:
-----

1.  **Computational Cost:** Training and using the model takes more time as you add more trees or make them deeper. While you can speed up training by using multiple processors, it still needs substantial computing power for big datasets.
2.  **Limited Interpretability:** While you can see which features are important overall, it’s harder to understand exactly why the model made a specific prediction, unlike with single decision trees. This can be a problem when you need to explain each decision.
3.  **Prediction Speed:** To make a prediction, data must go through all trees and then combine their answers. This makes Random Forests slower than simpler models, which might be an issue for real-time applications.

Final Remarks
-------------

I’ve grown to really like Random Forests after seeing how well they work in practice. By combining multiple trees and letting each one learn from different parts of the data, they consistently make better predictions — of course, more than using just one tree alone.

While you do need to adjust some settings like the number of trees, they usually perform well even without much fine-tuning. They do need more computing power (and sometimes struggle with rare cases in the data) but their reliable performance and ease of use make them my go-to choice for many projects. It’s clear why so many data scientists feel the same way!

🌟 Random Forest Classifier Code Summarized
-------------------------------------------

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_split  
from sklearn.metrics import accuracy\_score  
from sklearn.ensemble import RandomForestClassifierdataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rainy', 'rainy', 'rainy', 'overcast',   
                'sunny', 'sunny', 'rainy', 'sunny', 'overcast', 'overcast', 'rainy',  
                'sunny', 'overcast', 'rainy', 'sunny', 'sunny', 'rainy', 'overcast',  
                'rainy', 'sunny', 'overcast', 'sunny', 'overcast', 'rainy', 'overcast'\],  
    'Temperature': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
                   72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
                   88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humidity': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
                 90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
                 65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Play': \['No', 'No', 'Yes', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes',  
             'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'No', 'No', 'Yes', 'Yes',  
             'Yes', 'Yes', 'Yes', 'Yes', 'No', 'Yes'\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='', dtype=int)  
df\['Wind'\] = df\['Wind'\].astype(int)  
df\['Play'\] = (df\['Play'\] == 'Yes').astype(int)

column\_order = \['sunny', 'overcast', 'rainy', 'Temperature', 'Humidity', 'Wind', 'Play'\]  
df = df\[column\_order\]

X, y = df.drop('Play', axis=1), df\['Play'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

rf = RandomForestClassifier(n\_estimators=100, max\_features='sqrt', random\_state=42)  
rf.fit(X\_train, y\_train)

y\_pred = rf.predict(X\_test)  
print(f"Accuracy: {accuracy\_score(y\_test, y\_pred)}")

🌟 Random Forest Regressor Code Summarized
------------------------------------------

import pandas as pd  
import numpy as np  
from sklearn.model\_selection import train\_test\_split  
from sklearn.metrics import root\_mean\_squared\_error  
from sklearn.ensemble import RandomForestRegressordataset\_dict = {  
    'Outlook': \['sunny', 'sunny', 'overcast', 'rain', 'rain', 'rain', 'overcast',   
                'sunny', 'sunny', 'rain', 'sunny', 'overcast', 'overcast', 'rain',  
                'sunny', 'overcast', 'rain', 'sunny', 'sunny', 'rain', 'overcast',  
                'rain', 'sunny', 'overcast', 'sunny', 'overcast', 'rain', 'overcast'\],  
    'Temp.': \[85.0, 80.0, 83.0, 70.0, 68.0, 65.0, 64.0, 72.0, 69.0, 75.0, 75.0,  
              72.0, 81.0, 71.0, 81.0, 74.0, 76.0, 78.0, 82.0, 67.0, 85.0, 73.0,  
              88.0, 77.0, 79.0, 80.0, 66.0, 84.0\],  
    'Humid.': \[85.0, 90.0, 78.0, 96.0, 80.0, 70.0, 65.0, 95.0, 70.0, 80.0, 70.0,  
               90.0, 75.0, 80.0, 88.0, 92.0, 85.0, 75.0, 92.0, 90.0, 85.0, 88.0,  
               65.0, 70.0, 60.0, 95.0, 70.0, 78.0\],  
    'Wind': \[False, True, False, False, False, True, True, False, False, False, True,  
             True, False, True, True, False, False, True, False, True, True, False,  
             True, False, False, True, False, False\],  
    'Num\_Players': \[52, 39, 43, 37, 28, 19, 43, 47, 56, 33, 49, 23, 42, 13, 33, 29,  
                    25, 51, 41, 14, 34, 29, 49, 36, 57, 21, 23, 41\]  
}

df = pd.DataFrame(dataset\_dict)  
df = pd.get\_dummies(df, columns=\['Outlook'\], prefix='', prefix\_sep='')  
df\['Wind'\] = df\['Wind'\].astype(int)

X, y = df.drop('Num\_Players', axis=1), df\['Num\_Players'\]  
X\_train, X\_test, y\_train, y\_test = train\_test\_split(X, y, train\_size=0.5, shuffle=False)

rf = RandomForestRegressor(n\_estimators=100, max\_features='sqrt', random\_state=42)  
rf.fit(X\_train, y\_train)

y\_pred = rf.predict(X\_test)  
rmse = root\_mean\_squared\_error(y\_test, y\_pred)

print(f"Root Mean Squared Error: {rmse:.2f}")

Further Reading
---------------

For a detailed explanation of the [RandomForestClassifier](https://scikit-learn.org/1.5/modules/generated/sklearn.ensemble.RandomForestClassifier.html) and [RandomForestRegressor](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html) and its implementation in scikit-learn, readers can refer to the official documentation, which provides comprehensive information on its usage and parameters.

Technical Environment
---------------------

This article uses Python 3.7 and scikit-learn 1.5. While the concepts discussed are generally applicable, specific code implementations may vary slightly with different versions.

About the Illustrations
-----------------------

Unless otherwise noted, all images are created by the author, incorporating licensed design elements from Canva Pro.
